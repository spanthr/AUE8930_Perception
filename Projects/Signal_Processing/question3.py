# -*- coding: utf-8 -*-
"""question3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oqNxLB-NrIuXfYdUjjYG2ZZDMedn7BvX
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from numpy import pi,exp
import matplotlib.pyplot as plt
from pylab import *


mu=0
variance=1
sigma=np.sqrt(variance)

k=np.arange(500)
print(len(k))

x=[]
for i in range(len(k)):
  x.append(20)

s = np.random.normal(mu, sigma, 500)
signal=x+s

plt.plot(k,signal,k,x)
plt.title('Signal along with the normally distributed noise')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()

"""Analyzing the singnal in  the frequency domain"""
from scipy.fftpack import fft                                                     #import Fourier transform for converting to frequency domain

xft=fft(signal)
plt.plot(xft)
plt.title('Frequency Domain')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()



""" Kernel"""

""" Defining a function for performing the convolution"""
import numpy as np
def convolution(A,B):
  lengthA=np.size(A)
  lengthB=np.size(B)
  C = np.zeros(lengthA + lengthB -1)
  for m in np.arange(lengthA):
    for n in np.arange(lengthB):
      C[m+n] = C[m+n] + A[m]*B[n]
  return C

kern3=[0.27901,0.44198,0.27901]
kern11=[0.000003,	0.000229,0.005977,0.060598,0.24173,0.382925,0.24173,0.060598,0.005977,0.000229,0.000003]

C3=convolution(signal,kern3)
a=len(C3)-1
print(a)
C3=C3[1:a]
print(len(C3))
print(len(x))
plt.plot(k,C3,k,x)
plt.title('Applying kernel window size 3')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()

# print(len(kern11))
# for i in range (len(k)):
#   for j in range (len(kern3)):

C4=convolution(signal,kern11)
a=len(C4)-5
print(a)
C4=C4[5:a]
print(len(C4))
print(len(x))
plt.plot(k,C4,k,x)
plt.title('Applying kernel window size 11')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()





